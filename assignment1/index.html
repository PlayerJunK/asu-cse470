<!-- Gray Olson
CSE 470 -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<title>3D Sierpinski Gasket</title>


<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// HW470
varying vec4 fColor;

uniform float uTime;
uniform vec2 uResolution;

void main()
{
    // HW470
    vec2 uv = gl_FragCoord.xy / uResolution;
    float b = gl_FragCoord.z / uResolution.x;
    gl_FragColor = fColor + vec4(uv, b, 1.);
}
</script>

<script id="vertex-shader" type="x-shader/x-vertex">
// HW470 all
#define PI 3.14159265

attribute vec4 vPosition;
attribute vec3 vColor;

varying vec4 fColor;

uniform mat4 uProjection;
uniform mediump float uTime;

mat4 makeRotation3d(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}
void main()
{
    float d = distance(vPosition.xyz, vec3(0., 0., 0.));
    mat4 warp = makeRotation3d(vec3(0., 1., 0.), PI/3.*d*sin(uTime*1.25));
    mat4 rot = makeRotation3d(vec3(1., 0., 0.), -PI/8.) * makeRotation3d(vec3(0., 1., 0.), PI/6. - uTime + PI/3.*(cos(uTime*1.25) + 1.));
    mat4 totalRot = rot * warp;
    fColor = vec4(vColor, 1.0);
    gl_Position = uProjection * totalRot * vPosition;
}
</script>

<script type="text/javascript" src="../Common/webgl-utils.js"></script>
<script type="text/javascript" src="../Common/initShaders.js"></script>
<script type="text/javascript" src="../Common/MV.js"></script>
<script type="text/javascript" src="assignment1_over.js"></script>
</head>   

<body>
    <!--HW470: -->
    <h1>
        CSE 470 HW #1 Extra: 3D Sierpinski Gasket Twirl
    </h1>
    <p><em>Author:</em> Gray Olson <em>Date: </em>January 19, 2018.</p>
    <p><em>Description:</em> Displays four 2d Sierpinski gaskets in the shape of a pyramid with a twirly 3d matix transformation applied. Colored using pre-generated vertex colors per-side and per-vertex, which are also modified by a color derived the final clip-space coordinates in the fragment shader.</p>
    <p><em>Functionality:</em></p>
    <ul>
        <li>Each vertex of the original gasket is assigned a color based on a base color which is provided manually per-side as well as its (x,y,z) position. Since this position is inside the range [-1, 1] and colors are on the range [0, 1], the location of the vertex was multiplied by 0.5 and then 0.5 was added to each component. These are then multiplied with the base color. Finally a color is derived from the clip-space coordinates after transformations in the vertex shader and this color is then added to the base color derived at each vertex.</li>
        <li>Each vertex is transformed in the vertex shader first by creating a 3d rotation matrix about the Y axis with the angle of rotation being PI/4 * (distance from origin) * sin(time elapsed*1.25). It is then rotated about the y axis again by a factor of the time elapsed to create an animation and finally is rotated about the X axis so that the camera view is not straight on. It is then projected using an orthographic projection matrix generated by MV.js.</li>
        <li>Built-in depth sampling is used to ensure closer polygons are drawn on top of further ones.</li>
        <li>Vertex and color data is packed together into the same buffer and then extracted using vertex attributes with proper stride and offset applied.</li>
    </ul>
    <p><em>Parameters:</em></p>
    <ul>
        <li>NumTimesToSubdivide: Sets the number of recursions when performing the triangle subdividions.</li>
        <li>Morphing controlled by constants in the vertex shader, which gets multiplied by the distance from the origin of that vertex and the time elapsed since the start of the animation and then applied as a rotation about the origin.</li>
    </ul>
    <p><em>Resources: </em>Prof. Angel's code, examples of building a 3d rotation matrix, Mozilla developer reference for WebGL api.</p>
<canvas id="gl-canvas" width="1024" height="512">
Oops ... your browser doesn't support the HTML5 canvas element
</canvas>
</body>
</html>
